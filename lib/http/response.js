/**
 * @author Steven Jimenez <steven@stevethedev.com>
 */
'use strict';

const RegentObject = requireLib('util/regent-object');
const { _private } = requireLib('util/scope')();

/**
 * This class is responsible for providing a standardized Regent interface for
 * manipulating an {@link https://nodejs.org/api/http.html|HTTP Response} 
 * that was generated by the {@link HttpKernel}.
 */
class HttpResponse extends RegentObject
{
    /**
     * @param {HttpKernel}          httpKernel
     * @param {http.ServerResponse} httpResponse
     */
    constructor(httpKernel, httpResponse)
    {
        super(httpKernel.getRegent());

        /**
         * @protected
         * @property {HttpKernel}
         */
        _private(this).httpKernel = httpKernel;

        /**
         * @protected
         * @property {http.ServerResponse}
         */
        _private(this).httpResponse = httpResponse;

        /**
         * This is the HTTP Status Code to be sent to the client.
         * 
         * @protected
         * @property {Number}
         */
        _private(this).httpStatusCode = 200;

        /**
         * This is the response body that will be sent back to the client.
         *
         * @protected
         * @property {String}
         */
        _private(this).responseBody = '';

        /**
         * This is an indicator for whether the response has been sent or not.
         *
         * @type {Boolean}
         */
        _private(this).isSent = false;
    }

    /**
     * This function Sets a single header value on the pending HTTP response. 
     * If the header already exists, then the value will be replaced. If an 
     * array is provided for the second parameter, then multiple headers with 
     * the same name will be sent for each of the values. Attempting to set a 
     * header field name with invalid characters will result in a TypeError 
     * being thrown.
     * 
     * @param {String}          headerName
     * @param {String|String[]} headerValue
     *
     * @chainable
     */
    setHeader(headerName, headerValue)
    {
        _private(this).httpResponse.setHeader(headerName, headerValue);
        return this;
    }

    /**
     * This function is used to remove a header that's been queued for sending.
     *
     * @param {String} headerName
     *
     * @chainable
     */
    removeHeader(headerName)
    {
        _private(this).httpResponse.removeHeader(headerName);
        return this;
    }

    /**
     * This function is used to set a batch of headers on the pending HTTP
     * response at the same time.
     *
     * @param {Dictionary} headerDictionary
     *
     * @chainable
     */
    setHeaders(headerDictionary)
    {
        if (headerDictionary && 'object' == typeof _private(this).httpStatusCode) {
            Object.keys(headerDictionary).forEach(header => {
                this.setHeader(header, headerDictionary[header]);
            });
        }
        return this;
    }

    /**
     * This function is used to check whether a particular header has been
     * queued for sending to the client.
     *
     * @param {String} headerName
     *
     * @return {Boolean}
     */
    hasHeader(headerName)
    {
        return _private(this).httpResponse.hasHeader(headerName);
    }

    /**
     * This function is used to append a set of text values to the end of the
     * pending body content.
     *
     * @param {...String} content - The values to send to the client.
     *
     * @chainable
     */
    appendBody(...content)
    {
        content = sanitize(content);
        _private(this).responseBody = _private(this).responseBody + content.join('');
        return this;
    }

    /**
     * This function is used to prepend a set of text values to the start of
     * the pending body content.
     *
     * @param {...String} content - The values to send to the client.
     *
     * @chainable
     */
    prependBody(...content)
    {
        content = sanitize(content);
        _private(this).responseBody = content.join('') + _private(this).responseBody;
        return this;
    }

    /**
     * This function is used to overwrite the text content to be sent to
     * the client.
     *
     * @param {...String} content
     *
     * @chainable
     */
    setBody(...content)
    {
        content = sanitize(content);
        _private(this).responseBody = '' + content.join('');
        return this;
    }

    /**
     * Manually set an HTTP Status Code to return to the client
     *
     * @param {Number} statusCode
     *
     * @chainable
     */
    setStatusCode(statusCode) 
    {
        _private(this).httpStatusCode = statusCode;
        return this;
    }

    /**
     * This function finalizes the HTTP response and sends it to the client.
     *
     * @param {Number} statusCode
     *
     * @return {Promise}
     */
    send(statusCode = _private(this).httpStatusCode)
    {
        const callback = (resolve, reject) => {
            _private(this).httpStatusCode = statusCode;
            _private(this).httpResponse.writeHead(statusCode);
            _private(this).httpResponse.end(_private(this).responseBody, (err) => {
                if (err) {
                    return reject(err);
                }
                _private(this).isSent = true;
                return resolve();
            });
        };
        return new Promise(callback);
    }

    /**
     * Returns TRUE if the response has already been sent.
     */
    isSent()
    {
        return _private(this).isSent;
    }
}

function sanitize(content)
{
    return content.map((data) => {
        if (data && 'object' === typeof data) {
            return stringify(data);
        }
        return data;
    });
}

function stringify(object)
{
    try {
        return JSON.stringify(object);
    } catch(e) {
        return object;
    }
}

module.exports = HttpResponse;
