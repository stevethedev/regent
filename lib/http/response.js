/**
 * @author Steven Jimenez <steven@stevethedev.com>
 */
'use strict';

const Events          = requireLib('event/event-list');
const FileSystem      = requireLib('file/file-system');
const Mime            = requireLib('file/mime');
const RequestResponse = requireLib('core/request-response');
const { $protected }  = requireLib('util/scope')();

/**
 * This class is responsible for providing a standardized Regent interface for
 * manipulating an {@link https://nodejs.org/api/http.html|HTTP Response}
 * that was generated by the {@link HttpKernel}.
 */
class HttpResponse extends RequestResponse {
    /**
     * @param {HttpKernel}          httpKernel
     * @param {http.ServerResponse} httpResponse
     */
    constructor(httpKernel, httpResponse) {
        super(httpKernel.getRegent());

        /**
         * @protected
         * @property {HttpKernel}
         */
        $protected(this).httpKernel = httpKernel;

        /**
         * @protected
         * @property {http.ServerResponse}
         */
        $protected(this).httpResponse = httpResponse;

        /**
         * This is the HTTP Status Code to be sent to the client.
         *
         * @protected
         * @property {Number}
         */
        $protected(this).httpStatusCode = 200;

        /**
         * This is the response body that will be sent back to the client.
         *
         * @protected
         * @property {String}
         */
        $protected(this).responseBody = '';

        /**
         * This is an indicator for whether the response has been sent or not.
         *
         * @protected
         * @type {Boolean}
         */
        $protected(this).isSent = false;
    }

    /**
     * This function Sets a single header value on the pending HTTP response.
     * If the header already exists, then the value will be replaced. If an
     * array is provided for the second parameter, then multiple headers with
     * the same name will be sent for each of the values. Attempting to set a
     * header field name with invalid characters will result in a TypeError
     * being thrown.
     *
     * @param {String}          headerName
     * @param {String|String[]} headerValue
     *
     * @return {this}
     */
    setHeader(headerName, headerValue) {
        $protected(this).httpResponse.setHeader(headerName, headerValue);
        return this;
    }

    /**
     * This function is used to remove a header that's been queued for sending.
     *
     * @param {String} headerName
     *
     * @return {this}
     */
    removeHeader(headerName) {
        $protected(this).httpResponse.removeHeader(headerName);
        return this;
    }

    /**
     * This function is used to set a batch of headers on the pending HTTP
     * response at the same time.
     *
     * @param {Dictionary} headerDictionary
     *
     * @return {this} {foo} bar
     */
    setHeaders(headerDictionary) {
        const that = $protected(this);
        if (headerDictionary && 'object' === typeof that.httpStatusCode) {
            Object.keys(headerDictionary).forEach((header) => {
                this.setHeader(header, headerDictionary[header]);
            });
        }
        return this;
    }

    /**
     * This function is used to check whether a particular header has been
     * queued for sending to the client.
     *
     * @param {String} headerName
     *
     * @return {Boolean}
     */
    hasHeader(headerName) {
        return $protected(this).httpResponse.hasHeader(headerName);
    }

    /**
     * This function is used to append a set of text values to the end of the
     * pending body content.
     *
     * @param {...String} content - The values to send to the client.
     *
     * @return {this}
     */
    appendBody(...content) {
        const that = $protected(this);
        content = sanitize(content);
        that.responseBody = that.responseBody + content.join('');
        return this;
    }

    /**
     * This function is used to prepend a set of text values to the start of
     * the pending body content.
     *
     * @param {...String} content - The values to send to the client.
     *
     * @return {this}
     */
    prependBody(...content) {
        const that = $protected(this);
        content = sanitize(content);
        that.responseBody = content.join('') + that.responseBody;
        return this;
    }

    /**
     * This function is used to overwrite the text content to be sent to
     * the client.
     *
     * @param {...String} content
     *
     * @return {this}
     */
    setBody(...content) {
        content = sanitize(content);
        $protected(this).responseBody = content.join('');
        return this;
    }

    /**
     * Manually set an HTTP Status Code to return to the client
     *
     * @param {Number} statusCode
     *
     * @return {this}
     */
    setStatusCode(statusCode) {
        $protected(this).httpStatusCode = statusCode;
        return this;
    }

    /**
     * Send an HTTP response to the client
     *
     * @param {Number} statusCode
     *
     * @return {this}
     */
    async send(statusCode = $protected(this).httpStatusCode) {
        const that = $protected(this);
        const callback = (resolve, reject) => {
            this.call(fillCookies);
            that.httpStatusCode = statusCode;
            that.httpResponse.writeHead(statusCode);
            that.httpResponse.end(that.responseBody, (err) => {
                if (err) {
                    return reject(err);
                }
                that.isSent = true;
                return resolve(this);
            });
        };
        const response = await new Promise(callback);
        this.getRegent().getEmitter()
            .emit(Events.HTTP_AFTER_RESPONSE, this);
        return response;
    }

    /**
     * Send a file to the client
     *
     * @param {String} filePath
     * @param {Number} [statusCode]
     *
     * @return {this}
     */
    async stream(filePath, statusCode = $protected(this).httpStatusCode) {
        const fileSystem = new FileSystem(this.getRegent(), resolvePub());
        const mime = new Mime();

        this.setHeaders({
            'Content-Length': await fileSystem.getFileSize(filePath),
            'Content-Type'  : mime.getType(filePath),
        });

        this.call(fillCookies);

        $protected(this).httpResponse.writeHead(statusCode);

        await fileSystem.readStream(filePath, $protected(this).httpResponse);

        this.getRegent().getEmitter()
            .emit(Events.HTTP_AFTER_RESPONSE, this);

        return this;
    }

    /**
     * Returns TRUE if the response has already been sent.
     *
     * @return {Boolean}
     */
    isSent() {
        return $protected(this).isSent;
    }

    async render(template, options) {
        const templater = this.getRegent().getTemplater();
        const content = await templater.render(template, options);
        this.setBody(content);
        return this;
    }
}

function sanitize(content) {
    return content.map((data) => {
        if (data && 'object' === typeof data) {
            return stringify(data);
        }
        return data;
    });
}

function stringify(object) {
    try {
        return JSON.stringify(object);
    } catch (err) {
        return object;
    }
}

function fillCookies() {
    const cookies = $protected(this).cookies.getIterator();

    for (const cookie of cookies) {
        this.setHeader('Set-Cookie', cookie);
    }
    return this;
}

module.exports = HttpResponse;
